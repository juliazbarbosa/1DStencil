#include <chrono>
#include <iomanip>
#include <iostream>
#include <random>
#include "Timer.cuh"
#include "CheckError.cuh"
using namespace timer;

const int RADIUS = 1;
const int N = 10;

__global__
void stencilKernel(const int* d_input, int N, int* d_output) {
    int global_id = blockIdx.x * blockDim.x + threadIdx.x;
	
    if (global_id < N) {
        if (global_id == 0) {
            d_output[global_id] = d_input[global_id] + d_input[global_id + RADIUS];
        }
        else if (global_id == N - 1) {
            d_output[global_id] = d_input[global_id] + d_input[global_id - RADIUS];
        }
        else {
            d_output[global_id] = d_input[global_id - RADIUS] + d_input[global_id] + d_input[global_id + RADIUS];
        }
    }

}


int main() {
    Timer<DEVICE> TM_device;
    Timer<HOST>   TM_host;
    // -------------------------------------------------------------------------
    // HOST MEMORY ALLOCATION
    int* h_input      = new int[N];
    int* h_output_tmp = new int[N](); // <-- used for device result
    int* h_output     = new int[N](); // initilization to zero

    // -------------------------------------------------------------------------
    // HOST INITILIZATION
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    std::default_random_engine generator(seed);
    std::uniform_int_distribution<int> distribution(1, 100);

    for (int i = 0; i < N; i++)
        h_input[i] = distribution(generator);

    // -------------------------------------------------------------------------
    // HOST EXECUTIION
    TM_host.start();

    for (int i = 0; i < N; i++) {
        if (i == 0)
            h_output[i] = h_input[i] + h_input[i + RADIUS];
        else if (i == N - 1)
            h_output[i] = h_input[i] + h_input[i - RADIUS];
        else
            h_output[i] = h_input[i - RADIUS] + h_input[i] + h_input[i + RADIUS];
    }

    TM_host.stop();
    TM_host.print("1DStencil host:   ");

    // -------------------------------------------------------------------------
    // DEVICE MEMORY ALLOCATION
    int *d_input, *d_output;
    SAFE_CALL( cudaMalloc( &d_input, N * sizeof(int)) )
    SAFE_CALL( cudaMalloc( &d_output, N * sizeof(int)) )


    // -------------------------------------------------------------------------
    // COPY DATA FDimGrid,DimBlock>ROM HOST TO DEVIE
    SAFE_CALL(cudaMemcpy(d_input, h_input, N * sizeof(int), cudaMemcpyHostToDevice));
    // -------------------------------------------------------------------------
    // did you miss something?
    dim3 DimBlock(5, 1, 1);
	dim3 DimGrid((N + DimBlock.x - 1) / DimBlock.x, 1, 1);
    // -------------------------------------------------------------------------
    // DEVICE EXECUTION
    TM_device.start();

    stencilKernel<<< DimGrid,DimBlock >>>(d_input,N,d_output);
    cudaDeviceSynchronize();

    TM_device.stop();
    CHECK_CUDA_ERROR
    TM_device.print("1DStencil device: ");

    std::cout << std::setprecision(1)
              << "Speedup: " << TM_host.duration() / TM_device.duration()
              << "x\n\n";

    // -------------------------------------------------------------------------
    // COPY DATA FROM DEVICE TO HOST
    SAFE_CALL( cudaMemcpy( d_output_tmp, d_output, N * sizeof(int), cudaMemcpyDeviceToHost));

    // -------------------------------------------------------------------------
    // RESULT CHECK
	bool correct = true;
    for (int i = 0; i < N; i++) {
        if (h_output[i] != h_output_tmp[i]) {
            std::cerr << "wrong result at: " << i
                      << "\nhost:   " << h_output[i]
                      << "\ndevice: " << h_output_tmp[i] << "\n\n";
            correct = false;
        }
        
    }
	if (correct)
    	std::cout << "<> Correct\n\n";

    // -------------------------------------------------------------------------
    // HOST MEMORY DEALLOCATION
    delete[] h_input;
    delete[] h_output;
    delete[] h_output_tmp;

    // -------------------------------------------------------------------------
    // DEVICE MEMORY DEALLOCATION
    SAFE_CALL( cudaFree( d_input ) );
    SAFE_CALL( cudaFree( d_output ) );


    // -------------------------------------------------------------------------
    cudaDeviceReset();
}
